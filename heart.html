<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tr√°i tim nh·ªã ph√¢n 3D ‚ù§Ô∏è</title>
<style>
  :root { --bg:#050507; --accent:#ff4d6d; --accent2:#ff9fb1; }
  html,body { height:100%; margin:0; background: radial-gradient(ellipse at 50% 40%, #0b0b0d 0%, #050507 60%); font-family: "Segoe UI", Roboto, Arial; color:#fff; }
  canvas { display:block; margin:0 auto; width:100vw; height:100vh; }
  .overlay {
    position: absolute; left:0; right:0; top:16px; text-align:center;
    pointer-events:none; user-select:none;
    font-size:18px; color:rgba(255,255,255,0.85);
    text-shadow: 0 2px 12px rgba(0,0,0,0.6);
  }
  .msg {
    position:absolute; left:50%; transform:translateX(-50%); bottom:28px;
    font-size:16px; color:rgba(255,255,255,0.7);
  }
  /* small responsive tweak */
  @media (max-width:600px){ .overlay{font-size:14px} .msg{font-size:13px} }
</style>
</head>
<body>
  <div class="overlay">üíª Tr√°i tim nh·ªã ph√¢n 3D ‚Äî quay tr√°i ‚Üí ph·∫£i ‚ù§Ô∏è</div>
  <canvas id="c"></canvas>
  <div class="msg">Nh·∫•n Esc ƒë·ªÉ t·∫°m d·ª´ng / Resume b·∫±ng ph√≠m R</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  // resize for devicePixelRatio
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize);
  resize();

  // ----- Heart geometry -----
  // 2D heart parametric (classic)
  // t ‚àà [0, 2œÄ]: x = 16 sin^3 t, y = 13 cos t - 5 cos 2t - 2 cos 3t - cos 4t
  function heart2D(t) {
    const s = Math.sin(t), c=Math.cos(t);
    const x = 16 * s * s * s;
    const y = 13 * c - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return {x, y};
  }

  // generate points on a 3D "thick" heart surface by extruding small z
  const points = [];
  const uSteps = 160;   // around the rim
  const vSteps = 16;    // thickness
  const scaleBase = Math.min(innerWidth, innerHeight) / 40; // scale for heart size

  for (let i=0;i<uSteps;i++){
    const t = i / uSteps * Math.PI * 2;
    const p2 = heart2D(t);
    for (let j=0;j<vSteps;j++){
      // v in [-1,1] thickness
      const v = (j / (vSteps-1) - 0.5)*2;
      // make thickness vary along the heart: thicker near bottom
      const thicknessFactor = 1 - Math.abs(Math.sin(t)) * 0.6;
      const z = v * 20 * thicknessFactor; // z depth
      // small radial jitter to make pattern nicer
      const jitter = (Math.random()-0.5) * 0.6;
      points.push({
        x: p2.x * (1 + 0.02*jitter),
        y: p2.y * (1 + 0.02*jitter),
        z: z + jitter*2,
        uv: [t, v]
      });
    }
  }

  // Add a cloud of random binary points inside heart (fill)
  for (let k=0;k<1200;k++){
    const t = Math.random()*Math.PI*2;
    const r = Math.pow(Math.random(),0.9); // bias to center
    const p = heart2D(t);
    const x = p.x * (0.6 + 0.4*Math.random()) * r;
    const y = p.y * (0.6 + 0.4*Math.random()) * r;
    const z = (Math.random()-0.5)*28 * (0.5 + 0.5*Math.random());
    points.push({x,y,z, uv:[t,r]});
  }

  // projection params
  const fov = 400; // focal length
  const center = { x: innerWidth/2, y: innerHeight/2 };

  // animation control
  let t0 = performance.now();
  let paused = false;
  let rotateSpeed = 0.0016; // base speed
  let maxAngle = Math.PI/8; // swing amplitude (left-right)
  let lastFrameTime = t0;

  // controls
  addEventListener('keydown', (e) => {
    if (e.key === "Escape") paused = !paused;
    if (e.key.toLowerCase() === 'r') { paused = false; t0 = performance.now(); }
  });

  function render(now) {
    if (paused) {
      requestAnimationFrame(render);
      return;
    }
    const elapsed = now - t0;
    // swing angle: left-right using sin
    const angle = Math.sin(elapsed * rotateSpeed) * maxAngle;

    // Clear
    ctx.clearRect(0,0,innerWidth, innerHeight);
    // subtle vignette
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // sort points by depth after rotation for proper painter's algorithm
    const transformed = [];
    const cosA = Math.cos(angle), sinA = Math.sin(angle);

    for (let p of points) {
      // apply rotation about Y axis
      const x = p.x * cosA - p.z * sinA;
      const z = p.x * sinA + p.z * cosA;
      // small additional tilt so heart faces slightly up
      const tilt = -0.28; // rotate around x
      const y = p.y * Math.cos(tilt) - z * Math.sin(tilt);
      const z2 = p.y * Math.sin(tilt) + z * Math.cos(tilt);

      // perspective projection
      const proj = fov / (fov + z2);
      const sx = x * proj * scaleBase + center.x;
      const sy = -y * proj * scaleBase + center.y; // -y to flip
      transformed.push({sx, sy, z: z2, proj, orig: p});
    }

    // sort back-to-front
    transformed.sort((a,b) => b.z - a.z);

    // draw background soft glow (heart silhouette)
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.beginPath();
    for (let i=0;i<360;i+=6){
      const angle2 = i/360*Math.PI*2;
      const h = heart2D(angle2);
      // approximate z=0 projection
      const px = h.x * scaleBase * Math.cos(angle) + center.x;
      const py = -h.y * scaleBase * Math.cos(0.28) + center.y;
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
    const g = ctx.createRadialGradient(center.x, center.y-40, 30, center.x, center.y, Math.max(innerWidth, innerHeight));
    g.addColorStop(0, 'rgba(255,80,110,0.09)');
    g.addColorStop(0.4, 'rgba(255,80,110,0.025)');
    g.addColorStop(1, 'rgba(5,5,7,0)');
    ctx.fillStyle = g;
    ctx.fill();
    ctx.restore();

    // draw binary characters
    for (let i=0; i<transformed.length; i++){
      const it = transformed[i];
      const p = it.orig;
      // choose character 0/1 (can base on original uv to be stable)
      const char = (Math.floor((p.uv[0]*100 + (p.uv[1]*100)) ) % 2 === 0) ? '1' : '0';

      // size by depth
      const baseSize = 6 + 12 * it.proj; // 6..18
      const size = Math.max(2, baseSize * (0.9 + 0.6*Math.abs(Math.sin(it.orig.x + it.orig.y))));
      ctx.font = `${Math.round(size)}px "Courier New", monospace`;

      // color: deeper is darker, front is brighter
      const depthLight = Math.max(0, Math.min(1, (fov + it.z) / (fov + 60)));
      // hue shift from deep red to pink
      const r = Math.round(200 + 55 * depthLight);
      const gCol = Math.round(30 + 150 * depthLight);
      const b = Math.round(40 + 150 * (1-depthLight));
      // alpha by proj
      const alpha = 0.35 + 0.65 * it.proj * depthLight;

      ctx.fillStyle = `rgba(${r},${gCol},${b},${alpha.toFixed(2)})`;
      // small shadow to enhance 3D
      ctx.shadowColor = `rgba(0,0,0,${0.4*it.proj})`;
      ctx.shadowBlur = 2 + 8 * it.proj;
      ctx.fillText(char, it.sx - size*0.35, it.sy + size*0.35);
      ctx.shadowBlur = 0;
    }

    // center glossy highlight
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.ellipse(center.x, center.y-20, scaleBase*18, scaleBase*9, 0, 0, Math.PI*2);
    ctx.fill();

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
})();
</script>
</body>
</html>
